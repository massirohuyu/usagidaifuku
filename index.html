<!DOCTYPE html>
<html>
  <head>
    <title>Usagi Daifuku</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="http://cdn.rawgit.com/phi-jp/tmlib.js/0.4.4/build/tmlib.js" type="text/javascript"></script>
  </head>
  <body>
    
    <canvas id="world" width="640" height="480"></canvas>
    
    <script type="text/javascript">
      //確認用
      var test_app;
      
      (function(){
        
        var SCREEN_WIDTH    = 480, //12マス
            SCREEN_HEIGHT   = 640, //16マス
            SCREEN_CENTER_X = SCREEN_WIDTH/2,
            SCREEN_CENTER_Y = SCREEN_HEIGHT/2,
            BLOCK_WIDTH = 40,
            BLOCK_HEIGHT = 40,
            BLOCKS_NUMBER = 2,
            DIRECTION_LONG_TIME = 40,
            GAME_GRID_WIDTH = 12,
            GAME_GRID_HEIGHT = 10;
            
            

        /*
        * メイン処理(ページ読み込み後に実行される)
        */
        tm.main(function() {
            // アプリケーション作成
            var app = tm.app.CanvasApp("#world");
            app.resize(SCREEN_WIDTH, SCREEN_HEIGHT); // リサイズ
            app.fitWindow();    // 自動フィット

            // シーンを切り替える
            app.replaceScene(MainScene());

            // 実行
            app.run();
        });
        
        tm.define("MainScene", {
            superClass: "tm.app.Scene",

            init: function() {
                // 親の初期化
                this.superInit();
                
                this.block = tm.app.Label('test').addChildTo(this);
                this.block.setPosition(SCREEN_CENTER_X ,SCREEN_CENTER_Y );
                
                this.on('pointingend', function(){
                  this.app.replaceScene(GameScene());
                })
                
            },

            update: function(app) {
              
            }
        });
        
        tm.define("GameScene", {
            superClass: "tm.app.Scene",

            init: function() {
                // 親の初期化
                this.superInit();
                
                //Gridの準備
                this.gameGrid = this.createGrid();
                this.ctrlBlocksGrid = this.createGrid();

                //Blocksの準備
                this.ctrlBlocksGrid.initBlocks(this);
                
                //スマホ用コントローラーの設置
                this.smpController = this.createSmpController().addChildTo(this);
                this.smpController.setPosition( 120 ,SCREEN_HEIGHT - 120 );
                
                //押しキー判定用変数
                this.longPressedKey = false; //長押し中のキー
                this.pressedTimes = 0;
                
                //グローバルイベント処理
                this.on('pointingstart', function(){
                  
                })
            },

            update: function(app) {
                
                if( this.app.timer.frame%10 === 0) {
                  var moved = this.ctrlBlocksGrid.moveBlocks('down', this.gameGrid);
                  if(!moved){
                    this.gameGrid.add(this.ctrlBlocksGrid);
                    this.ctrlBlocksGrid.initBlocks(this);
                  };
                }
                
                //キー操作判定（leftかrightか）
                var direction = this.smpController.getDirection();
                if(app.keyboard.getKey('left')) direction = 'left';
                else if(app.keyboard.getKey('right')) direction = 'right';
                else if(app.keyboard.getKey('up')) direction = 'up';
                
                if(direction && this.longPressedKey !== direction) {
                  this.longPressedKey = direction;
                  this.pressedTimes = 0;
                } else if(direction && this.longPressedKey === direction) {
                  if( this.pressedTimes < DIRECTION_LONG_TIME) {
                    direction = false;
                    this.pressedTimes ++;
                  }
                } else {
                  this.longPressedKey = false;
                  this.pressedTimes = 0;
                }
                
                //キー判定による処理
                if(direction === 'left' || direction === 'right'){
                  this.ctrlBlocksGrid.moveBlocks(direction, this.gameGrid);
                }
                if(direction === 'up'){
                  console.log('up');
                }
            },

            createControlBlocks: function() {
              
            },

            createBlock: function() {
                var block = tm.app.RoundRectangleShape(40, 40);
                block.setFillStyle('#fff');
                return block;
            },
            
            createGrid: function() {
              var grid = [], _scene = this;
              
              grid.init = function(){
                grid.clear();
                grid.backGrid = grid.clear([]);
                grid.originBlock;
                return grid;
              }
              grid.clear = function(obj){
                var gridObj = grid;
                if(obj) gridObj = obj;
                for(var i = 0; i < GAME_GRID_HEIGHT; i++) {
                    gridObj[i] = [];
                  for(var j = 0; j < GAME_GRID_WIDTH; j++) {
                    gridObj[i][j] = false;
                  }
                }
                return gridObj;
              }
              grid.add = function(gridObj){
                if(!gridObj) return grid;
                for(var i = 0; i < GAME_GRID_HEIGHT; i++) {
                  for(var j = 0; j < GAME_GRID_WIDTH; j++) {
                    if(gridObj[i][j]) {
                      grid[i][j] = gridObj[i][j];
                    }
                  }
                }
                return grid;
              }
              grid.initBlocks = function(obj){
                var center = Math.round(GAME_GRID_WIDTH/2);
                grid.clear();
                for(var i = 0; i < BLOCKS_NUMBER; i++){
                  var block = _scene.createBlock();
                  grid[i][center] = block;
                  obj.addChild(block);
                  block.gridPos = [i, center];
                  block.setPosition(center*BLOCK_WIDTH, i*BLOCK_HEIGHT);
                  if(i === 0) grid.originBlock = block;
                }
                return grid;
              }
              grid.rotateBlocks = function(rotateDirection, comparedGrid){
                var rotateDirection = rotateDirection, rotateVal = 0,
                  originY = grid.originBlock.gridPos[0], originX = grid.originBlock.gridPos[1];
                if(rotateDirection) rotateDirection = 'right';
                grid.clear(grid.backGrid);
                
                switch(rotateDirection){
                  case 'left':
                    rotateVal = 1;
                    break;
                  case 'right':
                    rotateVal = -1;
                    break;
                }
                
                for(var i = 0; i < GAME_GRID_HEIGHT; i++) {
                  for(var j = 0; j < GAME_GRID_WIDTH; j++) {
                    if(grid[i][j]) {
                      var aftI = ((j-originX)*rotateVal)+originY,
                        aftJ = ((i-originY)*rotateVal*(-1))+originX;
                      if(typeof grid[aftI] === 'undefined' || typeof grid[aftI][aftJ] === 'undefined') return false;
                      else if(comparedGrid && comparedGrid[aftI][aftJ] !== false) return false;
                      grid.backGrid[aftI][aftJ] = grid[i][j];
                    }
                  }
                }
                
                for(var i = 0; i < GAME_GRID_HEIGHT; i++) {
                  for(var j = 0; j < GAME_GRID_WIDTH; j++) {
                      grid[i][j] = grid.backGrid[i][j];
                      if(grid[i][j]) {
                        //console.log(grid[i][j].tweener.move(j*BLOCK_WIDTH, i*BLOCK_HEIGHT));
                        grid[i][j].gridPos = [i, j];
                        grid[i][j].setPosition(j*BLOCK_WIDTH, i*BLOCK_HEIGHT);
                      }
                  }
                }
                
                return grid;
              }
              grid.moveBlocks = function(direction, comparedGrid){
                var dx = 0, dy = 0, comparedGrid = comparedGrid || false;
                if(!direction) return false;
                grid.clear(grid.backGrid);
                
                switch(direction){
                  case 'up':
                    dy = -1;
                    break;
                  case 'down':
                    dy = 1;
                    break;
                  case 'left':
                    dx = -1;
                    break;
                  case 'right':
                    dx = 1;
                    break;
                }
                
                for(var i = 0; i < GAME_GRID_HEIGHT; i++) {
                  for(var j = 0; j < GAME_GRID_WIDTH; j++) {
                    if(grid[i][j]) {
                      var aftI = i+dy,
                        aftJ = j+dx;
                      if(typeof grid[aftI] === 'undefined' || typeof grid[aftI][aftJ] === 'undefined') return false;
                      else if(comparedGrid && comparedGrid[aftI][aftJ] !== false) return false;
                      grid.backGrid[aftI][aftJ] = grid[i][j];
                    }
                  }
                }
                
                for(var i = 0; i < GAME_GRID_HEIGHT; i++) {
                  for(var j = 0; j < GAME_GRID_WIDTH; j++) {
                      grid[i][j] = grid.backGrid[i][j];
                      if(grid[i][j]) {
                        //console.log(grid[i][j].tweener.move(j*BLOCK_WIDTH, i*BLOCK_HEIGHT));
                        grid[i][j].gridPos = [i, j];
                        grid[i][j].setPosition(j*BLOCK_WIDTH, i*BLOCK_HEIGHT);
                      }
                  }
                }
                
                return grid;
              }
              
              return grid.init();
            },

            createSmpController: function() {
                var smpController = tm.app.Shape(110, 110),
                  smpControllerBtn = tm.app.CircleShape(80, 80).setFillStyle('#888');
          
                smpController.addChild(tm.app.CircleShape(120, 120).setFillStyle('#fff'));
                smpController.addChild(smpControllerBtn);
                smpController.setInteractive(true);
                smpController.dx = 0;
                smpController.dy = 0;
                console.log(smpControllerBtn);
                smpController.on('pointingstart', function(e){
                  this.px = e.pointing.x;
                  this.py = e.pointing.y;
                })
                smpController.on('pointingmove', function(e){
                  this.dx = e.pointing.x - this.px;
                  this.dy = e.pointing.y - this.py;
                  smpControllerBtn.x = this.dx;
                  smpControllerBtn.y = this.dy;
                })
                smpController.on('pointingend', function(){
                  this.dx = 0;
                  this.dy = 0;
                  smpControllerBtn.x = 0;
                  smpControllerBtn.y = 0;
                })
                smpController.getDirection = function(){
                  var direction = false,
                      unreactedDist = 30;
                  if(Math.abs(this.dx) < unreactedDist && Math.abs(this.dy) < unreactedDist ){
                    return false;
                  }
                  
                  if(Math.abs(this.dx) > Math.abs(this.dy)){
                    if(this.dx > 0) direction = 'right';
                    else direction = 'left';
                  }
                  else if(Math.abs(this.dx) < Math.abs(this.dy)){
                    if(this.dy > 0) direction = 'down';
                    else direction = 'up';
                  }
                  
                  return direction;
                }
                return smpController;
            }
        });
        
      })();
    </script>
  </body>
</html>
